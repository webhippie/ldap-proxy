// generaTed by fileb0x at "2017-07-07 21:58:34.199615232 +0200 CEST" from config file "ab0x.yaml"

package templates

import (
	"bytes"
	"compress/gzip"
	"io"
	"log"
	"net/http"
	"os"

	"golang.org/x/net/context"
	"golang.org/x/net/webdav"
)

var (
	// CTX is a context for webdav vfs
	CTX = context.Background()

	// FS is a virtual memory file system
	FS = webdav.NewMemFS()

	// Handler is used to server files through a http handler
	Handler *webdav.Handler

	// HTTP is the http file system
	HTTP http.FileSystem = new(HTTPFS)
)

// HTTPFS implements http.FileSystem
type HTTPFS struct{}

// FileLayoutTmpl is "./layout.tmpl"
var FileLayoutTmpl = []byte("\x1f\x8b\x08\x00\x00\x09\x6e\x88\x00\xff\x7c\x92\x31\xef\xdb\x20\x10\xc5\xe7\xf8\x53\x50\xe6\x10\xd4\xad\x03\x58\xaa\xd2\x0c\x9d\xda\x21\x95\xda\x91\xc0\x39\x5c\x83\xc1\x85\x8b\x53\xcb\xf2\x77\xaf\x6c\x27\xea\x5f\xfa\x47\x99\xe0\xb8\xf7\x7e\x80\xde\xa9\x0f\x5f\xbe\xed\x8f\xbf\xbe\x1f\x98\xa7\x36\xd4\x55\xa5\xe6\x95\x05\x13\xcf\x9a\x43\xe4\x75\xb5\x51\x1e\x8c\xab\xab\xcd\x46\xb5\x40\x86\x59\x6f\x72\x01\xd2\xfc\x4a\x8d\xf8\xc4\xdf\x34\x52\x24\x88\xa4\xf9\x0d\x1d\x79\xed\xa0\x47\x0b\x62\x29\xb6\x0c\x23\x12\x9a\x20\x8a\x35\x01\xf4\xc7\x2d\x2b\x3e\x63\xbc\x08\x4a\xa2\x41\xd2\x31\x71\x16\x4d\x0b\x9a\xf7\x08\xb7\x2e\x65\x7a\x06\xfe\x7a\xd0\xe0\xce\xc0\x99\x27\xea\x04\xfc\xb9\x62\xaf\xf9\x4f\xf1\xe3\xb3\xd8\xa7\xb6\x33\x84\xa7\x00\xbc\xae\xde\x1b\x1f\x70\x07\xc5\x66\xec\x08\x53\x7c\xc6\x7f\xc8\xcc\x95\x7c\xca\x77\x12\x21\x05\xa8\xc7\x91\xed\x8e\xf3\x8e\x4d\x93\x92\xeb\xd9\xd2\x0e\x18\x2f\x2c\x43\xd0\x1c\x6d\x8a\x9c\xf9\x0c\x8d\xe6\x32\x38\xd3\x89\x2e\xa7\xbf\x83\x34\xa5\x00\x15\xd9\x98\x7e\x56\xec\xd0\xa6\xf5\xee\xff\xce\x42\x43\x80\xe2\x01\xe8\x85\x7f\x29\x76\xb6\x14\xce\xe4\x9c\x8a\xbc\xc7\xa2\x4e\xc9\x0d\x33\x70\x1c\xd9\x80\x10\x1c\x9b\xa6\xe5\x65\xeb\x57\x59\xc9\xf6\x05\xef\x77\xe1\xb5\x92\xab\x74\xa1\xae\x34\x25\xd7\x71\xf8\x17\x00\x00\xff\xff\x6e\xe8\xef\x04\x1f\x02\x00\x00")

// FileLoginTmpl is "./login.tmpl"
var FileLoginTmpl = []byte("\x1f\x8b\x08\x00\x00\x09\x6e\x88\x00\xff\xbc\x54\xc1\x8e\xdc\x20\x0c\x3d\x67\xbf\x02\x71\xa7\xd1\x6a\xaf\xc9\xdc\x7b\xab\xd4\xf6\x03\x3c\xe0\x4c\xd0\x12\x8c\xc0\x99\xdd\xe9\x6a\xff\xbd\x0a\x90\x88\x99\x1e\x5b\xf5\x84\xed\x67\x3f\x1e\xcf\x12\x83\xb1\x57\xa1\x1d\xa4\x34\xca\xf5\x55\x4d\x0e\xdf\x45\x3d\x95\x46\xcf\x18\xe5\xe9\xa9\x7b\xe8\xd2\x10\x8d\xa8\xa7\x32\x38\xc1\xea\xf8\xc8\x67\xba\x62\x3c\xb2\x33\x99\xdb\xc6\xd0\x0d\xf3\x4b\xc3\x30\x23\x18\xeb\x2f\xca\x59\x8f\x19\xee\x86\x14\xc0\xe7\xa8\xfb\xf8\x10\x5f\x7e\x58\x76\x28\x3e\x3f\x33\xd4\xef\xd8\xd0\xcf\x2f\xa7\xa7\x2d\xb8\x17\x04\x0e\x23\x2b\x03\xfe\x82\x51\x8a\xbd\x50\x78\xe1\x8f\x3e\xed\x28\x61\x6e\xcb\xd1\x69\xe8\x21\x93\x76\x43\x28\x02\xbe\x7a\x4d\x31\xa2\x66\xb1\x26\x8c\x1e\x16\x14\x14\x45\x80\x94\xde\x28\x9a\x22\x29\x14\x3d\xc6\x5e\x8b\xa0\x89\xe2\xd2\x1a\x49\x71\x51\x89\x41\xbf\xa2\x91\x62\x41\x9e\xc9\x8c\x32\x50\x62\x29\x40\xb3\x25\x3f\xca\xde\x19\x08\x2a\x44\x7a\xbf\xf5\x8e\x2e\xd6\x57\x27\xee\xdf\xb6\x40\x3c\xa0\x6e\x70\x70\x46\xf7\x78\x4f\x2e\x4a\x31\x51\x1c\xe5\xae\xb8\x0e\x74\x3f\x6b\x5e\xc6\xfb\xdc\x5a\xb9\x1e\x56\xbf\x31\x69\xf2\x1c\xc9\xa5\x7d\x7a\xb0\x3e\xac\xdc\x74\xe5\x5c\x0a\x6b\x9a\x9b\x04\xdf\x02\x36\x79\x19\xed\x60\x65\x9a\x48\xaf\x69\x94\x47\xd8\x62\x1a\x82\x65\x70\xf6\x17\x8e\x92\xa6\xe9\x0e\x2a\xf6\x97\x7a\x55\x5b\xac\xee\x5a\xd3\xff\xd2\xaa\x7d\xa1\xfb\x63\xbf\x35\x0b\xfe\x77\x56\x15\x73\x8e\xbb\xb2\x75\x47\xf6\x1f\xed\x38\xaf\xcc\xe4\x1b\xb8\x16\x8e\x48\x85\x68\x17\x88\xb7\xad\xf2\x66\x0d\xcf\xea\x59\x3d\x8b\x83\x47\xa5\x05\x9c\x53\x67\x62\xa6\x65\x7f\xf4\x77\x7b\xf1\xc2\xfa\x2a\xa9\xf0\xb4\xaa\xb6\x60\x73\x6b\xfb\x43\x4a\xa5\x1e\xbf\x03\x00\x00\xff\xff\x1d\x8e\xd5\xe6\x78\x04\x00\x00")

func init() {
	if CTX.Err() != nil {
		log.Fatal(CTX.Err())
	}

	var err error

	var f webdav.File

	var rb *bytes.Reader
	var r *gzip.Reader

	rb = bytes.NewReader(FileLayoutTmpl)
	r, err = gzip.NewReader(rb)
	if err != nil {
		log.Fatal(err)
	}

	err = r.Close()
	if err != nil {
		log.Fatal(err)
	}

	f, err = FS.OpenFile(CTX, "./layout.tmpl", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		log.Fatal(err)
	}

	_, err = io.Copy(f, r)
	if err != nil {
		log.Fatal(err)
	}

	err = f.Close()
	if err != nil {
		log.Fatal(err)
	}

	rb = bytes.NewReader(FileLoginTmpl)
	r, err = gzip.NewReader(rb)
	if err != nil {
		log.Fatal(err)
	}

	err = r.Close()
	if err != nil {
		log.Fatal(err)
	}

	f, err = FS.OpenFile(CTX, "./login.tmpl", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)
	if err != nil {
		log.Fatal(err)
	}

	_, err = io.Copy(f, r)
	if err != nil {
		log.Fatal(err)
	}

	err = f.Close()
	if err != nil {
		log.Fatal(err)
	}

	Handler = &webdav.Handler{
		FileSystem: FS,
		LockSystem: webdav.NewMemLS(),
	}
}

// Open a file
func (hfs *HTTPFS) Open(path string) (http.File, error) {
	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	return f, nil
}

// ReadFile is adapTed from ioutil
func ReadFile(path string) ([]byte, error) {
	f, err := FS.OpenFile(CTX, path, os.O_RDONLY, 0644)
	if err != nil {
		return nil, err
	}

	buf := bytes.NewBuffer(make([]byte, 0, bytes.MinRead))

	// If the buffer overflows, we will get bytes.ErrTooLarge.
	// Return that as an error. Any other panic remains.
	defer func() {
		e := recover()
		if e == nil {
			return
		}
		if panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {
			err = panicErr
		} else {
			panic(e)
		}
	}()
	_, err = buf.ReadFrom(f)
	return buf.Bytes(), err
}

// WriteFile is adapTed from ioutil
func WriteFile(filename string, data []byte, perm os.FileMode) error {
	f, err := FS.OpenFile(CTX, filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	if err != nil {
		return err
	}
	n, err := f.Write(data)
	if err == nil && n < len(data) {
		err = io.ErrShortWrite
	}
	if err1 := f.Close(); err == nil {
		err = err1
	}
	return err
}

// FileNames is a list of files included in this filebox
var FileNames = []string{
	"./layout.tmpl",
	"./login.tmpl",
}
